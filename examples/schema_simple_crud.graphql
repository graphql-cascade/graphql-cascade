# GraphQL Cascade Example: Simple CRUD
# This schema demonstrates basic CRUD operations with Cascade compliance
# Convention: All mutations return CascadeResponse, queries follow naming conventions

"""
Base schema imports - all Cascade schemas must include these
"""
interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int
}

interface CascadeResponse {
  success: Boolean!
  errors: [CascadeError!]
  data: MutationPayload
  cascade: CascadeUpdates!
}

type CascadeUpdates {
  updated: [UpdatedEntity!]!
  deleted: [DeletedEntity!]!
  invalidations: [QueryInvalidation!]!
  metadata: CascadeMetadata!
}

type UpdatedEntity {
  __typename: String!
  id: ID!
  operation: CascadeOperation!
  entity: Node!
}

type DeletedEntity {
  __typename: String!
  id: ID!
  deletedAt: DateTime!
}

type QueryInvalidation {
  queryName: String
  queryPattern: String
  strategy: InvalidationStrategy!
  scope: InvalidationScope!
}

enum CascadeOperation {
  CREATED
  UPDATED
  DELETED
}

enum InvalidationStrategy {
  INVALIDATE
  REFETCH
  REMOVE
}

enum InvalidationScope {
  EXACT
  PREFIX
  PATTERN
  ALL
}

type CascadeMetadata {
  timestamp: DateTime!
  depth: Int!
  affectedCount: Int!
}

type CascadeError {
  message: String!
  code: CascadeErrorCode!
  field: String
  path: [String!]
  extensions: JSON
}

enum CascadeErrorCode {
  VALIDATION_ERROR
  NOT_FOUND
  UNAUTHORIZED
  FORBIDDEN
  CONFLICT
  INTERNAL_ERROR
  TRANSACTION_FAILED
}

scalar DateTime
scalar JSON
scalar MutationPayload

# Directives
directive @cascade(
  maxDepth: Int = 3
  includeRelated: Boolean = true
  autoInvalidate: Boolean = true
  excludeTypes: [String!]
) on FIELD_DEFINITION

directive @cascadeInvalidates(
  queries: [String!]!
  strategy: InvalidationStrategy = INVALIDATE
) on FIELD_DEFINITION

# Domain entities

"""
User entity - implements required interfaces
"""
type User implements Node & Timestamped {
  id: ID!
  email: String! @cascadeInvalidates(queries: ["searchUsers", "listUsers"])
  name: String! @cascadeInvalidates(queries: ["searchUsers", "listUsers"])
  role: UserRole!
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: Int
}

enum UserRole {
  ADMIN
  USER
  GUEST
}

# Input types

input CreateUserInput {
  email: String!
  name: String!
  role: UserRole = USER
}

input UpdateUserInput {
  email: String
  name: String
  role: UserRole
}

# Response types

type CreateUserCascade implements CascadeResponse {
  success: Boolean!
  errors: [CascadeError!]
  data: User
  cascade: CascadeUpdates!
}

type UpdateUserCascade implements CascadeResponse {
  success: Boolean!
  errors: [CascadeError!]
  data: User
  cascade: CascadeUpdates!
}

type DeleteUserCascade implements CascadeResponse {
  success: Boolean!
  errors: [CascadeError!]
  data: User
  cascade: CascadeUpdates!
}

# Queries

type Query {
  """
  Get a single user by ID.
  Convention: get<EntityType>
  """
  getUser(id: ID!): User

  """
  List users with pagination.
  Convention: list<EntityType>s
  """
  listUsers(args: PaginationArgs): UserConnection

  """
  Search users by name or email.
  Convention: search<EntityType>s
  """
  searchUsers(query: String!, args: PaginationArgs): UserConnection
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

input PaginationArgs {
  first: Int
  last: Int
  after: String
  before: String
}

input UserFilter {
  role: UserRole
  emailContains: String
  nameContains: String
  isActive: Boolean
}

enum UserOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
}

# Mutations

type Mutation {
  """
  Create a new user.
  Convention: create<EntityType>
  Response: Create<EntityType>Cascade
  """
  createUser(input: CreateUserInput!): CreateUserCascade!
    @cascade(maxDepth: 1)

  """
  Update an existing user.
  Convention: update<EntityType>
  Response: Update<EntityType>Cascade
  """
  updateUser(id: ID!, input: UpdateUserInput!): UpdateUserCascade!
    @cascade(maxDepth: 2)

  """
  Delete a user.
  Convention: delete<EntityType>
  Response: Delete<EntityType>Cascade
  """
  deleteUser(id: ID!): DeleteUserCascade!
    @cascade(maxDepth: 1)
}

# When User.email or User.name changes:
# - cascade.updated includes: User
# - cascade.invalidations includes: listUsers, searchUsers, getUser